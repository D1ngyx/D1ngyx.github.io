<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[C++] [ROS] CPP基础开发环境配置 | My New Hugo Site</title><link rel=stylesheet href=/css/style.css></head><body><header class=topbar><nav><ul class=menu><li class=menu-left><button id=toggleSidebar>DirNav 🗺️</button></li><li><a href=/>Home 🏠</a></li><li><a href=/posts/>Posts 📚</a></li><li><a href=/tags/>Tags 🏷️</a></li></ul></nav></header><div class=container><aside class="sidebar hidden" id=sidebar><div class=resizer id=resizer></div><div class=toc><h3>Directory</h3><ul><nav id=TableOfContents><ul><li><a href=#1-提供语言服务>1. 提供语言服务</a><ul><li><a href=#11--基本逻辑>1.1 基本逻辑</a></li><li><a href=#12-具体实现>1.2 具体实现</a></li><li><a href=#13-dummy-技巧可选>1.3 Dummy 技巧（可选）</a></li></ul></li><li><a href=#2-在-vscode-中使用>2. 在 Vscode 中使用</a></li><li><a href=#3-在-neovim-中使用>3. 在 Neovim 中使用</a></li></ul></nav></ul></div></aside><main class=content><article><h1>[C++] [ROS] CPP基础开发环境配置</h1><p><strong>摘要：</strong> 这里的 CPP 开发环境，指的是为文本编辑器配置特定语言的补全以及诊断功能。显示的配置方式有很多，这里只展示本人在<strong>工作中</strong>经常用到的一种。经实测，适用于常规 <strong>CPP</strong> 项目开发，或者 <strong>ROS</strong> 中的 CPP 项目开发。</br></br></p><h2 id=1-提供语言服务>1. 提供语言服务</h2><h3 id=11--基本逻辑>1.1 基本逻辑</h3><p>现代文本编辑器的语言支持，依赖语言服务协议（LanguageServerProtocol, LSP），来为文本编辑器实时检测功能。</p><img src=/images/cppconfig_overall.png alt=cppconfig_overall><p>本质来说，实现语言服务功能，是要让文本编辑器能够读取到编译时需要的各种路径和库，从而实现语言支持。</p><p>对于常规的 <code>cmake</code>，或者是 ros 中的 <code>catkin_make</code>，可以通过 <code>-DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code> 来生成一个叫做 <code>compile_commands.json</code> 的文件。</p><p>简单来说，我们只需要让文本编辑器，读取这个 compile_commands.json 里面的内容，就可以实现基本的补全、高亮、诊断的基础语言服务功能了。</p><h3 id=12-具体实现>1.2 具体实现</h3><p>假设我们在一个标准的 CPP 开发项目目录中，结构如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dingyx in ~/Temporary/cpp_project_root
</span></span><span style=display:flex><span>&gt; tree
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>├── build
</span></span><span style=display:flex><span>├── CMakeLists.txt
</span></span><span style=display:flex><span>├── include
</span></span><span style=display:flex><span>└── src
</span></span></code></pre></div><p>通过以下命令来生成 compile_commands.json 到 build 目录中 (<strong>cmake 和 catkin_make 都适用</strong>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cmake -Bbuild -DCMAKE_EXPORT_COMPILE_COMMANDS<span style=color:#ff79c6>=</span>ON
</span></span></code></pre></div><p>由此，您应该能够在 build 目录下看到一个 compile_commands.json 文件。</p><p>需要注意的是 compile_commands.json 文件是<strong>不会</strong> 自动更新的，如果您修改代码或者头文件，必须 <strong>重新</strong> 编译并使用 -DCMAKE_EXPORT_COMPILE_COMMANDS=ON 参数。</p><p>此外，您也可以直接在 CMakeLists.txt 中设置 CMAKE_EXPORT_COMPILE_COMMANDS 参数为 ON。</p><h3 id=13-dummy-技巧可选>1.3 Dummy 技巧（可选）</h3><p>您应该在一些项目中看到过类似 dummy.cpp 的文件，这是生成 compile_commands.json 的一种 <strong>trick</strong>。</p><p>有时候，<strong>不方便</strong> 重新编译整个项目来直接生成 compile_commands.json 文件。</p><p>此时，常见的方法，是通过创建一个 dummy.cpp 文件（当然，文件名可以随便定义，常见的是 dummy.cpp），来导入所有头文件，然后编译 dummy.cpp 文件，来把所有头文件导入进来，一个示例如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#6272a4>// src/dummy.cpp
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 导入项目中使用的所有头文件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;...&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;...&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>...
</span></span><span style=display:flex><span><span style=color:#6272a4>// 随便写一个 main 函数
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd>int</span> main() {
</span></span><span style=display:flex><span>  std<span style=color:#ff79c6>::</span>cout <span style=color:#ff79c6>&lt;&lt;</span> <span style=color:#f1fa8c>&#34;include all you need&#34;</span> <span style=color:#ff79c6>&lt;&lt;</span> std<span style=color:#ff79c6>::</span>endl;
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p></br></br></p><h2 id=2-在-vscode-中使用>2. 在 Vscode 中使用</h2><p>Vscdoe 的配置非常简单，只需要在 CPP 的配置文件中指定 compile_commands.json 的路径即可。</p><p>通过 Ctrl (cmd) + Shift + p 打开 Vscode 的命令面板，找到 C++ 的配置选项。</p><img src=/images/cppconfig_forvscode.png alt=vscode_config style=zoom:50%><p>打开后，插入 <code>"compileCommands": "path/to/your/compile_commands.json"</code> 代码即可。一个示例如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;configurations&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;name&#34;</span>: <span style=color:#f1fa8c>&#34;Mac&#34;</span>,
</span></span><span style=display:flex><span>          	<span style=color:#6272a4>//////// 加上这条代码，指定 compile_commands.json 的路径 ////////
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>          	<span style=color:#ff79c6>&#34;compileCommands&#34;</span>: <span style=color:#f1fa8c>&#34;${workspaceFolder}/build/compile_commands.json&#34;</span>,
</span></span><span style=display:flex><span>          	<span style=color:#6272a4>/////////////////////////////////////////////////////////////
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>&#34;includePath&#34;</span>: [
</span></span><span style=display:flex><span>                <span style=color:#f1fa8c>&#34;${workspaceFolder}/**&#34;</span>
</span></span><span style=display:flex><span>            ],
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;defines&#34;</span>: [],
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;compilerPath&#34;</span>: <span style=color:#f1fa8c>&#34;/usr/bin/clang&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;cStandard&#34;</span>: <span style=color:#f1fa8c>&#34;c17&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;cppStandard&#34;</span>: <span style=color:#f1fa8c>&#34;c++14&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;intelliSenseMode&#34;</span>: <span style=color:#f1fa8c>&#34;macos-clang-arm64&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;version&#34;</span>: <span style=color:#bd93f9>4</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p></br></br></p><h2 id=3-在-neovim-中使用>3. 在 Neovim 中使用</h2><p>Neovim 的配置比较底层，要直接通过 Clangd 的 CLI 接口，定义 Clangd 应该从项目根目录的哪个路径下读取 compile_commands.json。</p><p>具体的细节，如果您使用 Neovim，我认为您大概率具备对 Clangd 文档的阅读、理解、使用能力。这里给出<strong>个人配置示例</strong>以供参考：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>local</span> <span style=color:#ff79c6>function</span> <span style=color:#50fa7b>setup_cpp_lsp</span>()
</span></span><span style=display:flex><span>  vim.lsp.start({
</span></span><span style=display:flex><span>    name <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;clangd&#39;</span>,
</span></span><span style=display:flex><span>    cmd <span style=color:#ff79c6>=</span> {<span style=color:#f1fa8c>&#39;clangd&#39;</span>, <span style=color:#f1fa8c>&#39;--background-index&#39;</span>, <span style=color:#f1fa8c>&#39;--clang-tidy&#39;</span>, <span style=color:#f1fa8c>&#39;--compile-commands-dir=build&#39;</span>, <span style=color:#f1fa8c>&#39;--header-insertion=never&#39;</span>},
</span></span><span style=display:flex><span>    filetypes <span style=color:#ff79c6>=</span> {<span style=color:#f1fa8c>&#39;cpp&#39;</span>, <span style=color:#f1fa8c>&#39;c&#39;</span>},
</span></span><span style=display:flex><span>    root_dir <span style=color:#ff79c6>=</span> vim.fs.root(<span style=color:#bd93f9>0</span>, {<span style=color:#f1fa8c>&#39;.git&#39;</span>, <span style=color:#f1fa8c>&#39;CMakeLists.txt&#39;</span>}),
</span></span><span style=display:flex><span>    settings <span style=color:#ff79c6>=</span> {},
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span><span style=color:#ff79c6>end</span>
</span></span></code></pre></div><p>配置在 <code>'--compile-commands-dir=build'</code> 这里，这实际上是 Clangd 官方文档中提供的 CLI。</p><p>这表明 Neovim 会去 <code>项目根目录</code> 下的 <code>build</code> 文件夹搜索并使用 <code>compile_commands.json</code> 文件。如果没有配置，默认是在项目根目录中搜索，这您可以根据使用习惯自由设置。</p></article></main></div><script src=/js/sidebar.js></script></body></html>